<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on COMP2221 – Functional Programming</title><link>https://comp2221.github.io/fp-website/</link><description>Recent content in Introduction on COMP2221 – Functional Programming</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://comp2221.github.io/fp-website/index.xml" rel="self" type="application/rss+xml"/><item><title>Hello, World!</title><link>https://comp2221.github.io/fp-website/exercises/exercise1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/exercises/exercise1/</guid><description>Beginnings # GHC provides either a compiler, with which we can compile a Haskell program into an executable, and an interpreter with a read-eval-print-loop. Initially, we&amp;rsquo;ll start off using the interpreter. It can be invoked with ghci, so at a terminal prompt run
$ ghci When I show commands in the terminal, I will use a $ to indicate the prompt (which you should not type), followed by the command to type.</description></item><item><title>Slides &amp; commentary</title><link>https://comp2221.github.io/fp-website/past-editions/2021-22/lectures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/past-editions/2021-22/lectures/</guid><description>Lecture slides and video links # As the course progressed, I added the annotated slides and live code examples, along with links to the videos (accessible with a Durham account), and some commentary.
2022-01-10: Annotated slides, video, code
We got most of the way through the slides, and then did some live examples. We same some very simple functions and probably quite a lot of syntax that we&amp;rsquo;ll go through in more detail as the course progresses.</description></item><item><title>Slides &amp; Recordings</title><link>https://comp2221.github.io/fp-website/past-editions/2022-23/lectures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/past-editions/2022-23/lectures/</guid><description>Lecture slides and video links # As the course progresses, I&amp;rsquo;ll add the annotated slides and live code examples, along with links to the videos (accessible with a Durham account) to this page.
2023-01-09: Slides, video, code
We got most of the way through the slides, and then did some live examples. We defined and composed some very simple functions and saw a bit of Haskell syntax that we will consider in more detail as the course progresses.</description></item><item><title>Slides &amp; Recordings</title><link>https://comp2221.github.io/fp-website/slides/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/slides/</guid><description>Lecture slides and video links # As the course progresses, I&amp;rsquo;ll add the annotated slides and live code examples, along with links to the videos (accessible with a Durham account) to this page.
2024-01-08: Slides, video, code
We got most of the way through the slides, and then did some live examples. We defined and composed some very simple functions and saw a bit of Haskell syntax that we will consider in more detail as the course progresses.</description></item><item><title>Types and lists</title><link>https://comp2221.github.io/fp-website/exercises/exercise2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/exercises/exercise2/</guid><description>Thinking about types # You&amp;rsquo;ve probably noticed by now that GHC will complain if you write some code where the types don&amp;rsquo;t match. To do this, it uses type inference to determine the valid types of any functions you write, and checks that everything works. For example, suppose I have a function
allTrue :: [Bool] -&amp;gt; Bool allTrue [] = True allTrue (x:xs) = x &amp;amp;&amp;amp; allTrue xs which checks if every entry of a list of Bools is True.</description></item><item><title>Annotated slides</title><link>https://comp2221.github.io/fp-website/past-editions/2020-21/lectures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/past-editions/2020-21/lectures/</guid><description>Lecture slides and video links # As the course progressed, I uploaded lecture slides, the live code examples, and added links to the videos (accessible with a Durham account).
2021-01-12: Annotated slides, video, code
We got about halfway through the slides, we&amp;rsquo;ll pick up where we left off next time.
2021-01-14: Annotated slides, video, code
We went through the remainder of the slides from Tuesday. I skipped over the dark blue slides introducing Haskell syntax since we saw that in the coding examples as well.</description></item><item><title>List manipulation and sorting</title><link>https://comp2221.github.io/fp-website/exercises/exercise3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/exercises/exercise3/</guid><description>More list manipulation # We&amp;rsquo;ll start off doing a bit more list manipulation, looking at some list comprehensions and pattern matching. Then we&amp;rsquo;ll implement merge sort.
List comprehensions &amp;amp; pattern matching # For this section, the template code is code/lists-exercise3.hs.
Let&amp;rsquo;s first look at some pattern matching, and combination with guard expressions.
Exercise Write a function compress :: Eq a =&amp;gt; [a] -&amp;gt; [a] that eliminates consecutive duplicate elements of a list, but otherwise leaves the order unchanged.</description></item><item><title>Lazy evaluation and infinite datastructures</title><link>https://comp2221.github.io/fp-website/exercises/exercise4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/exercises/exercise4/</guid><description>Lazy data, infinite data # Haskell does not evaluate expressions eagerly, but instead does so lazily. This opens the door to writing very succint programs that operator on infinite datastructures. We can just write them without needing to have a cut-off and then pick out the pieces we want.
For some more examples, on top of the ones we have here, there&amp;rsquo;s a nice Computerphile video on infinite datastructures, featuring Graham Hutton.</description></item><item><title>Folds and function composition</title><link>https://comp2221.github.io/fp-website/exercises/exercise5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/exercises/exercise5/</guid><description>Higher order functions # foldl and foldr # Many functions that apply to lists can be written, as we saw in lectures, in the form:
f [] = v f (x:xs) = x `op` f xs which turns the empty list into some initial value (here v) and all other lists to the result of apply a specified binary operator op to the head of the list and the result of recursion on the tail.</description></item><item><title>Some classic data structures</title><link>https://comp2221.github.io/fp-website/exercises/exercise6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/exercises/exercise6/</guid><description>Manipulating data types # A binary tree # In lectures we saw (repeatedly) a binary tree with values at nodes and empty leaves. This time, we&amp;rsquo;re going to make a tree that holds values at nodes and leaves, and then do some manipulation of it.
Our data type is
data Tree a = Leaf a | Node (Tree a) a (Tree a) deriving (Eq, Show) The template code/trees-exercise6.hs also defines some helper functions to construct trees of various kinds</description></item><item><title>Another mini expression evaluator</title><link>https://comp2221.github.io/fp-website/exercises/exercise7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/exercises/exercise7/</guid><description>Checking for satisfiability # In this exercise, we&amp;rsquo;re going to develop a very simple SAT solver. To do so, we&amp;rsquo;ll first build data structures to represent boolean expressions. An expression is SAT if there is a consistent assignment of boolean values to the variables in the expression such that it evaluates to True.
The point of this exercise is not to develop a good SAT solver. We are doing the naivest possible thing.</description></item><item><title>Model Exam</title><link>https://comp2221.github.io/fp-website/exercises/exercise8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://comp2221.github.io/fp-website/exercises/exercise8/</guid><description>Model Exam # Please consider the model exam and answers in advance to the practical sessions of the week commencing the 22nd of April 2024. The sessions will be drop-in sessions where you can get answers to remaining questions about the content of past lectures, exercises and the model exam.</description></item></channel></rss>